# This class based on ParseConfig gem (Author is BJ Dierkes <wdierkes@5dollarwhitebox.org>)
# This class was written to simplify the parsing of configuration
# files in the format of "param = value".

class ConfigParser
  
  attr_accessor  :params
  
  # Initialize the class with the path to the 'config_file'
  # The class objects are dynamically generated by the
  # name of the 'param' in the config file.  Therefore, if
  # the config file is 'param = value' then the itializer
  # will eval "@param = value"
  # if config_file not defined then remember settings from command line
  # command line argument should be in pattern <opts="settings_name_a=value_a, settings_name_b=value_b, ..."> 
  def initialize(config_files=nil)
    @params = {}
    if config_files
      config_files.each{|file| parse_from_file(file)}
    else
      opts = ENV['OPTS'] 
      if opts and (not opts.empty?)
        opts.split(",").each { |opt_line| set_var_from(opt_line) if opt_line }
      end
    end
  end
  
  
  # This method will provide the value held by the object "@param"
  # where "@param" is actually the name of the param in the config
  # file.
  def get_value(param)
    self.instance_variable_get("@#{param}")
  end
  
  # This method is simple.  Should you need to override a value
  # dynamically, use override_value(param, value) where 'param' is
  # the name of the paramater in the config file.
  #
  def override_value(param, value)
    self.instance_variable_set("@#{param}", value)
  end
  
  # This method will set the value of '@param' to nil (not in the config
  # file, only in the app).
  def nil_value(param)
    self.instance_variable_set("@#{param}", nil)
  end
  
  # return all defined settings' names for this instance
  def get_params_keys()
    return self.params.keys
  end
  
  # Try to convert value from string to other types (int, boolean, float)
  # return value as String if all of tries were failed
  # If value is not String, return it as is.
  def try_convert_value(value)
    if value.class == String
      if /^[0-9]+$/.match(value) #int
        return value.to_i
      elsif /^[0-9]+(\.)[0-9]*$/.match(value) #float
        return value.to_f
      elsif (value.downcase == "true") #boolean
        return true
      elsif (value.downcase == "false") #boolean
        return false
      else
        return value # can't parse, return String
      end
    else # value is not String, return it as is
      return value
    end
  end
  
  
  #  try parse setting's line
  #  delimiter is "=", ignores single and double quotes in the start and end positions
  def parse_setting(line)
    raise ArgumentError, "Invalid pair: #{line}. Expected: name=value" unless line["="]
    param, value = line.split(/\s*=\s*/, 2)
    var_name = param.chomp.strip
    value = value.chomp.strip if value
    new_value = ''
    if (value)
     new_value = (value =~ /^["](.*)["]$/) ?  $1 : value
    end
    new_value = try_convert_value(new_value)
    return var_name, new_value
  end
  
  # parse settings file. Raise exception if file does not exist
  # if line starts  with "#" symbol line ignores   
  def parse_from_file(config_file)
    if !File.readable?(config_file)
      raise Errno::EACCES, "#{config_file} is not readable"
    end
    
    open(config_file).each { |line|
      line.strip!
      unless (/^\#/.match(line))
        set_var_from(line) if  (/\s*=\s*/.match(line))
      end
    }
  end
  
  def set_var_from(line)
    var_name, new_value = parse_setting(line)
    self.instance_variable_set("@#{var_name}", new_value)
    self.params["#{var_name}"] = new_value
  end
  
end