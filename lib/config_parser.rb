# This class was written to simplify the parsing of configuration
# files in the format of "param = value".
module AppSettings
  class ConfigParser

    attr_accessor :params

    # Initialize the class with the path to the 'config_file'
    # The class objects are dynamically generated by the
    # name of the 'param' in the config file.  Therefore, if
    # the config file is 'param = value' then the initializer
    # will eval "@param = value"
    # if config_file not defined then remember settings from command line
    # command line argument should be in pattern <settings_name_a=value_a, settings_name_b=value_b, ...>
    def initialize(config_files=nil)
      @params = {}
      if config_files
        config_files.each { |file| parse_from_file(file) }
      else
        if ENV and (not ENV.empty?)
          ENV.each { |name, value| set_var_from("#{name}=#{value}") if name }
        end
      end
    end


    # This method will provide the value held by the object "@param"
    # where "@param" is actually the name of the param in the config
    # file.
    def get_value(param)
      self.params[param]
    end

    # This method is simple.  Should you need to override a value
    # dynamically, use override_value(param, value) where 'param' is
    # the name of the paramater in the config file.
    #
    def override_value(param, value)
      self.params[param] = value
    end

    # This method will set the value of '@param' to nil (not in the config
    # file, only in the app).
    def nil_value(param)
      self.params[param] = nil
    end

    # return all defined settings' names for this instance
    def get_params_keys()
      return self.params.keys
    end

    # Try to convert value from string to other types (int, boolean, float)
    # return value as String if all of tries were failed
    # If value is not String, return it as is.
    def try_convert_value(value)
      if value.class == String
        if /^[0-9]+$/.match(value) #int
          return value.to_i
        elsif /^[0-9]+(\.)[0-9]*$/.match(value) #float
          return value.to_f
        elsif (value.downcase == "true") #boolean
          return true
        elsif (value.downcase == "false") #boolean
          return false
        else
          return value # can't parse, return String
        end
      else # value is not String, return it as is
        return value
      end
    end


    #  try parse setting's line
    #  delimiter is "=", ignores single and double quotes in the start and end positions
    def parse_setting(line)
      raise ArgumentError, "Invalid pair: #{line}. Expected: name=value" unless line["="]
      param, value = line.split(/\s*=\s*/, 2)
      raise ArgumentError, "Invalid pair: #{line}. Expected: non empty name" if (param.nil? or param.empty?)

      var_name = param.chomp.strip
      value = value.chomp.strip if value
      new_value = ''
      if (value)
        new_value = (value =~ /^["](.*)["]$/) ? $1 : value
      end
      new_value = try_convert_value(new_value)
      return var_name, new_value
    end

    # parse settings file. Raise exception if file does not exist
    # if line starts  with "#" symbol line ignores
    def parse_from_file(config_file)
      if !File.readable?(config_file)
        raise Errno::EACCES, "#{config_file} is not readable"
      end

      open(config_file).each { |line|
        line.strip!
        unless (/^\#/.match(line))
          set_var_from(line) if  (/\s*=\s*/.match(line))
        end
      }
    end

    def set_var_from(line)
      var_name, new_value = parse_setting(line)
      self.params["#{var_name}"] = new_value
    end

  end
end